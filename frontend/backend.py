import pprint
from ir import *
from symbol import *

class Backend(object):
    pass

class RegisterAllocator():
    def __init__(self, registers):
        self.all_registers = registers
        self.available = []
        self.reserved = []

        # deepcopy list
        for reg in self.all_registers:
            self.available.append(reg)

    def _valid_register(self, register):
        return register in self.all_registers

    def reserve(self, register):
        if not self._valid_register(register):
            raise ValueError("Unknown register %s to reserve" % register)

        if register not in self.reserved:
            self.available.remove(register)
            self.reserved.append(register)
            return register
        else:
            raise ValueError("Cannot reserve %s: already reserved" % register)

    def reserve_any(self):
        if len(self.available) == 0:
            return None

        return self.reserve(self.available[0])

    def release(self, register):
        if not self._valid_register(register):
            raise ValueError("Unknown register %s to reserve" % register)

        if register in self.reserved:
            self.available.append(register)
            self.reserved.remove(register)
        else:
            raise ValueError("Cannot release %s: not reserved" % register)

class CBackend(Backend):
    def __init__(self, ir, environment):
        self.ir = ir
        self.env = environment
        self.label_count = 0
        self.code = []

    def EMIT(self, label, insn):
        self.code += [[label, insn]]

    def new_label(self):
        self.label_count += 1
        # note: we need an underscore at the end of the autogenerated labels
        # otherwise "L1" and "L11" will be ambigious
        return "L%d_" % self.label_count

    def _allocate_registers(self):

        def islive(variable, ir):
            for i, stmt in enumerate(ir):
                if stmt.dst == variable:
                    return stmt, i

                if isinstance(stmt.src, IRBinop):
                    if stmt.src.lhs == variable:
                        return stmt, i
                    if stmt.src.rhs == variable:
                        return stmt, i
                elif isinstance(stmt.src, IRByteCmp):
                    if stmt.src.byte_string == variable:
                        return stmt, i
                elif isinstance(stmt.src, IRCall):
                    pass
                elif isinstance(stmt.src, IRExpr):
                    raise ValueError("Unhandled IR object expression %s" % repr(stmt.src))

            return None, None

        interference_graph = {}

        for i, stmt in enumerate(self.ir):
            start_ref = i

            tmp = stmt.dst

            if tmp in interference_graph:
                raise ValueError("temporary %s assigned multiple times (not SSA form)" % tmp)

            # figure out how long the temporary is used
            next_ref, next_idx = islive(tmp, self.ir[i+1:])

            if next_ref is None:
                end_ref = i
            else:
                end_ref = next_idx+i+1

            crosses_call = False

            # figure out if the temporary's usage crosses a call boundary
            for fwd_idx, fwd_stmt in enumerate(self.ir[i+1:]):
                if (fwd_idx+i+1) > end_ref:
                    break

                if isinstance(fwd_stmt.src, IRCall) or isinstance(fwd_stmt.src, IRByteCmp):
                    crosses_call = True
                    break

            interference_graph[tmp] = {"start": start_ref, "end": end_ref, "crosses_call": crosses_call}

        #pprint.pprint(interference_graph)

        temp_map = {}
        reg = RegisterAllocator(["BPF_REG_6", "BPF_REG_7", "BPF_REG_8"])
        special_reg = RegisterAllocator(["BPF_REG_0", "BPF_REG_1", "BPF_REG_2", "BPF_REG_3", "BPF_REG_4", "BPF_REG_5"])

        # allocate registers (huehuehue)
        register_pressure = 0
        live_tmps = []
        for i, stmt in enumerate(self.ir):
            dst = stmt.dst
            src = stmt.src
            register_local = None
            register_special = False

            inter = interference_graph[dst]

            if inter["crosses_call"]:
                register_local = reg.reserve_any()
            else:
                register_local = special_reg.reserve_any()
                register_special = True

            if register_local is None:
                raise ValueError("Ran out of registers at stmt %d, temporary %s" % (i, dst))

            temp_map[dst] = register_local
            live_tmps.append({"temp_name" : dst, "name": register_local, "special": register_special})

            if len(live_tmps) > register_pressure:
                register_pressure = len(live_tmps)

            # Check if each temporary is still live from the current statement
            # Make sure to create a temporary list to allow removal of entries from the list
            for tmp in [x for x in live_tmps]:
                inter = interference_graph[tmp["temp_name"]]

                if i >= inter["end"]:
                    live_tmps.remove(tmp)

                    if tmp["special"]:
                        special_reg.release(tmp["name"])
                    else:
                        reg.release(tmp["name"])

        #print("Register pressure: %d" % register_pressure)

        return temp_map

    def compile(self):
        temp_map = self._allocate_registers()

        # label (optional), insn
        self.EMIT("LSTART", "")

        # Save the context somewhere safe
        self.EMIT("", "BPF_MOV64_REG(BPF_REG_9, BPF_REG_1)")

        for stmt in self.ir:
            dst = stmt.dst
            src = stmt.src
            tmp_ref = temp_map[dst]

            if isinstance(src, IRBinop):
                op = src.op

                if op == "EQ" or op == "NE" or op == "LT" or op == "LTE" or op == "GT" or op == "GTE":
                    lhs = src.lhs
                    rhs = src.rhs
                    jumpkind = ""

                    if op == "EQ":    jumpkind = "BPF_JEQ"
                    elif op == "NE":  jumpkind = "BPF_JNE"
                    elif op == "LT":  jumpkind = "BPF_JLT"
                    elif op == "LTE": jumpkind = "BPF_JLE"
                    elif op == "GT":  jumpkind = "BPF_JGT"
                    elif op == "GTE": jumpkind = "BPF_JGE"
                    else: assert 0

                    if isinstance(lhs, IRTemp) and isinstance(rhs, Number):
                        tmp = temp_map[lhs]
                        label = self.new_label()

                        self.EMIT("", "BPF_MOV64_IMM(%s, 1)" % (tmp_ref))
                        self.EMIT("", "BPF_JMP_IMM(%s, %s, %d, %s)" % (jumpkind, tmp, rhs.value, label))
                        self.EMIT("", "BPF_MOV64_IMM(%s, 0)" % (tmp_ref))
                        self.EMIT(label, "")
                    elif isinstance(lhs, IRTemp) and isinstance(rhs, IRTemp):
                        tmp_lhs = temp_map[lhs]
                        tmp_rhs = temp_map[rhs]
                        label = self.new_label()

                        self.EMIT("", "BPF_MOV64_IMM(%s, 1)" % (tmp_ref))
                        self.EMIT("", "BPF_JMP_REG(%s, %s, %s, %s)" % (jumpkind, tmp_lhs, tmp_rhs, label))
                        self.EMIT("", "BPF_MOV64_IMM(%s, 0)" % (tmp_ref))
                        self.EMIT(label, "")
                    else:
                        raise ValueError("Unsupported operand combination for binop(EQ): %s %s" % (type(lhs), type(rhs)))
                elif op == "AND":
                    lhs = src.lhs
                    rhs = src.rhs

                    lhs_temp = temp_map[lhs]
                    rhs_temp = temp_map[rhs]

                    cond_false = self.new_label()
                    cond_end = self.new_label()

                    self.EMIT("", "BPF_JMP_IMM(BPF_JEQ, %s, 0, %s)" % (lhs_temp, cond_false))
                    self.EMIT("", "BPF_JMP_IMM(BPF_JEQ, %s, 0, %s)" % (rhs_temp, cond_false))
                    self.EMIT("", "BPF_MOV64_IMM(%s, 1)" % (tmp_ref))
                    self.EMIT("", "BPF_JMP_A(%s)" % (cond_end))
                    self.EMIT(cond_false, "BPF_MOV64_IMM(%s, 0)" % (tmp_ref))
                    self.EMIT(cond_end, "")
                elif op == "OR":
                    lhs = src.lhs
                    rhs = src.rhs

                    lhs_temp = temp_map[lhs]
                    rhs_temp = temp_map[rhs]

                    cond_true = self.new_label()
                    cond_end = self.new_label()

                    self.EMIT("", "BPF_JMP_IMM(BPF_JNE, %s, 0, %s)" % (lhs_temp, cond_true))
                    self.EMIT("", "BPF_JMP_IMM(BPF_JNE, %s, 0, %s)" % (rhs_temp, cond_true))
                    self.EMIT("", "BPF_MOV64_IMM(%s, 0)" % (tmp_ref))
                    self.EMIT("", "BPF_JMP_A(%s)" % (cond_end))
                    self.EMIT(cond_true, "BPF_MOV64_IMM(%s, 1)" % (tmp_ref))
                    self.EMIT(cond_end, "")
                else:
                    raise ValueError("Unsupported binop: " + op)
            elif isinstance(src, IRLoadCtx):
                # This makes the assumption that BPF_REG_9 stores the context
                self.EMIT("", "BPF_LDX_MEM(BPF_W, %s, BPF_REG_9, %d)" % (tmp_ref, src.offset))
            elif isinstance(src, IRCall):
                # This makes the assumption that BPF_REG_9 stores the context
                # Restore the context for the function call
                self.EMIT("", "BPF_MOV64_REG(BPF_REG_1, BPF_REG_9)")
                self.EMIT("", "BPF_CALL_FUNC(BPF_FUNC_%s)" % (src.name))
                self.EMIT("", "BPF_MOV64_REG(%s, BPF_REG_0)" % (tmp_ref))
            # XXX: IRByteCmp is a leaky abstraction. The byte cmp should be
            # done entirely at the IR level, but our IR is too weak :'(
            elif isinstance(src, IRByteCmp):
                match_label = self.new_label()
                bad_label = self.new_label()
                end_procedure = self.new_label()

                # Get the length of the string to compare
                self.EMIT("", "BPF_MOV64_REG(BPF_REG_1, BPF_REG_9)")
                self.EMIT("", "BPF_CALL_FUNC(BPF_FUNC_%s)" % (src.length_fn))
                self.EMIT("", "BPF_MOV64_IMM(%s, %d)" % (tmp_ref, len(src.byte_string)))

                # string_len != byte_string_len -> goto out (fastpath)
                self.EMIT("", "BPF_JMP_REG(BPF_JNE, BPF_REG_0, %s, %s)" % (tmp_ref, bad_label))

                # Do we need to worry about endianess here?
                # Pad the byte string if necessary
                if len(src.byte_string) % 8 != 0:
                    bytes_to_cmp = src.byte_string + "\x00"*(8 - len(src.byte_string) % 8)

                # okay we have strings that match in length, lets compare them
                # for each set of 8-bytes
                for word_cnt in range(len(bytes_to_cmp)/8):
                    from struct import unpack

                    self.EMIT("", "BPF_MOV64_REG(BPF_REG_1, BPF_REG_9)")
                    self.EMIT("", "BPF_MOV64_IMM(BPF_REG_2, %d)" % (word_cnt*8))
                    self.EMIT("", "BPF_CALL_FUNC(BPF_FUNC_%s)" % (src.byte_fn))

                    chunk = unpack("<Q", bytes_to_cmp[word_cnt*8:(word_cnt+1)*8])[0]
                    self.EMIT("", "BPF_LD_IMM64(%s, 0x%016xUL)" % (tmp_ref, chunk))
                    self.EMIT("", "BPF_JMP_REG(BPF_JNE, BPF_REG_0, %s, %s)" % (tmp_ref, bad_label))

                self.EMIT(match_label, "BPF_MOV64_IMM(%s, 1)" % (tmp_ref))
                self.EMIT("", "BPF_JMP_A(%s)" % (end_procedure))
                self.EMIT(bad_label, "BPF_MOV64_IMM(%s, 0)" % (tmp_ref))
                self.EMIT(end_procedure, "")
            elif isinstance(src, Number):
                self.EMIT("", "BPF_LD_IMM64(%s, 0x%016xUL)" % (tmp_ref, src.value))
            else:
                raise ValueError("Unsupported IR: " + str(type(src)));

        drop_packet = self.new_label()
        allow_packet = self.new_label()

        last_result = temp_map[self.ir[-1].dst]

        # if last_result != 0:
        #   goto drop
        # else:
        #   goto allow

        self.EMIT("", "BPF_JMP_IMM(BPF_JNE, %s, 0, %s)" % (last_result, drop_packet))
        self.EMIT(allow_packet, "BPF_MOV64_IMM(BPF_REG_0, 0)")
        self.EMIT("", "BPF_EXIT_INSN()")
        self.EMIT(drop_packet, "BPF_MOV64_IMM(BPF_REG_0, 1)")

        # return code should be in R0
        self.EMIT("LEND", "BPF_EXIT_INSN()")

        return self.code

    def assemble(self, program):
        # pc, label, insn
        new_program = []

        # a map of labels to PC values
        labels = {}
        pc = 0

        # Pass 1: clean up instructions and label PC values
        for idx, insn in enumerate(program):
            insn[0] = insn[0].strip().rstrip()
            insn[1] = insn[1].strip().rstrip()

            # blank line
            if len(insn[0]) == 0 and len(insn[1]) == 0:
                continue

            # We have a label
            if len(insn[0]) > 0:
                if insn[0] in labels:
                    raise ValueError("Duplicate label found during assembly: %s" % insn[0])

                labels[insn[0]] = pc

            # We have an instruction
            if len(insn[1]) > 0:
                new_program.append([pc, insn[1]])

                if insn[1].startswith('BPF_LD_IMM64'): # special case
                    pc += 2
                else:
                    pc += 1

        # Pass 2: replace labels with PC-relative values
        for idx, insn in enumerate(new_program):
            pc = insn[0]
            insn = insn[1]

            new_program[idx] = insn

            # O(n^2) label replace
            for label, label_pc in labels.iteritems():
                pos = insn.find(label)

                if pos == -1:
                    continue

                # Minus 1 as PC points to the next instruction
                delta = label_pc - pc - 1

                if delta <= 0:
                    raise ValueError("PC-relative branch is negative or zero: address %d" % pc)

                new_program[idx] = insn.replace(label, str(delta))

        return new_program
